////////////////////////////////////////////////////////////////////////////////
// Filename: texture.ps
////////////////////////////////////////////////////////////////////////////////
//texture pixel shader有两个全局变量。第一个是Texture2D类型的shaderTexture，保存了用于在模型上进行渲染的贴图资源。第二个是采样器状态（SamplerState）类型的SampleType，它描述了渲染时怎样将贴图上的像素绘制到多边形上。举例来说，如果多边形很远，绘制时在屏幕上仅有8个像素，采样器状态来指明原贴图中那个像素的颜色或如何混合多个像素后的颜色会用于绘制。原贴图有256x256个像素，必须选对要绘制的像素才能保证最终绘制的小物体看起来真实，因此如何选择非常重要。TextureShaderClass会设置采样器状态，然后把它绑定到资源指针（resource pointer，显卡资源在内存中映射的（对象的？）指针），这样给就能把采样器状态传递给pixel shader以绝对如何选择像素进行绘制。

/////////////
// GLOBALS //
/////////////
Texture2D shaderTexture;
SamplerState SampleType;

//We have two new global variables inside the LightBuffer that hold the diffuse color and the direction of the light. These two variables will be set from values in the new LightClass object.
//The light constant buffer is updated with a new 4 float ambient color value. This will allow the ambient color to be set in this shader by outside classes. 
cbuffer LightBuffer
{
    float4 ambientColor;
    float4 diffuseColor;
    float3 lightDirection;
    float padding;
};



//为了给Pixel shader使用，pixelInputType也用纹理坐标替代了颜色值。

//////////////
// TYPEDEFS //
//////////////
struct PixelInputType
{
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
    float3 normal : NORMAL;
};
//pixelshader也开始使用HLSL采样函数。采样函数以我们上面提到的采样器状态和多边形上当前绘制的点的纹理坐标作为输入。它通过这两个变量决定返回什么颜色。

////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 LightPixelShader(PixelInputType input) : SV_TARGET
{
    float4 textureColor;
    float3 lightDir;
    float lightIntensity;
    float4 color;


    // Sample the pixel color from the texture using the sampler at this texture coordinate location.
    textureColor = shaderTexture.Sample(SampleType, input.tex);
	
	// We set the output color value to the base ambient color. All pixels will now be illuminated by a minimum of the ambient color value.
    // Set the default output color to the ambient light value for all pixels.
    color = ambientColor;
	
	//This is where the lighting equation that was discussed earlier is now implemented. The light intensity value is calculated as the dot product between the normal vector of triangle and the light direction vector.

	// Invert the light direction for calculations.
    lightDir = -lightDirection;
	 
	// Calculate the amount of light on this pixel.
    lightIntensity = saturate(dot(input.normal, lightDir));
	
	//Check if the N dot L is greater than zero. If it is then add the diffuse color to the ambient color. If not then you need to be careful to not add the diffuse color. The reason being is that the diffuse color could be negative and it will subtract away some of the ambient color in the addition which is not correct.

    if(lightIntensity > 0.0f)
    {
        // Determine the final diffuse color based on the diffuse color and the amount of light intensity.
        color += (diffuseColor * lightIntensity);
    }

	//Make sure to saturate the final output light color since the combination of ambient and diffuse could have been greater than 1.
    // Saturate the final light color.
    color = saturate(color);
	
    // Multiply the texture pixel and the final diffuse color to get the final pixel color result.
    color = color * textureColor;
    return color;
}